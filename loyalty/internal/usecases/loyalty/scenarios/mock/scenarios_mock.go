// Code generated by MockGen. DO NOT EDIT.
// Source: internal/usecases/loyalty/scenarios/scenarios.go

// Package mock is a generated GoMock package.
package mock

import (
	context "context"
	reflect "reflect"

	dto "github.com/Axel791/loyalty/internal/usecases/loyalty/dto"
	gomock "github.com/golang/mock/gomock"
)

// MockInputUserBalanceUseCase is a mock of InputUserBalanceUseCase interface.
type MockInputUserBalanceUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockInputUserBalanceUseCaseMockRecorder
}

// MockInputUserBalanceUseCaseMockRecorder is the mock recorder for MockInputUserBalanceUseCase.
type MockInputUserBalanceUseCaseMockRecorder struct {
	mock *MockInputUserBalanceUseCase
}

// NewMockInputUserBalanceUseCase creates a new mock instance.
func NewMockInputUserBalanceUseCase(ctrl *gomock.Controller) *MockInputUserBalanceUseCase {
	mock := &MockInputUserBalanceUseCase{ctrl: ctrl}
	mock.recorder = &MockInputUserBalanceUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockInputUserBalanceUseCase) EXPECT() *MockInputUserBalanceUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method.
func (m *MockInputUserBalanceUseCase) Execute(ctx context.Context, orderID int64, balance dto.LoyaltyBalance) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, orderID, balance)
	ret0, _ := ret[0].(error)
	return ret0
}

// Execute indicates an expected call of Execute.
func (mr *MockInputUserBalanceUseCaseMockRecorder) Execute(ctx, orderID, balance interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockInputUserBalanceUseCase)(nil).Execute), ctx, orderID, balance)
}

// MockGetUserBalanceUseCase is a mock of GetUserBalanceUseCase interface.
type MockGetUserBalanceUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockGetUserBalanceUseCaseMockRecorder
}

// MockGetUserBalanceUseCaseMockRecorder is the mock recorder for MockGetUserBalanceUseCase.
type MockGetUserBalanceUseCaseMockRecorder struct {
	mock *MockGetUserBalanceUseCase
}

// NewMockGetUserBalanceUseCase creates a new mock instance.
func NewMockGetUserBalanceUseCase(ctrl *gomock.Controller) *MockGetUserBalanceUseCase {
	mock := &MockGetUserBalanceUseCase{ctrl: ctrl}
	mock.recorder = &MockGetUserBalanceUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGetUserBalanceUseCase) EXPECT() *MockGetUserBalanceUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method.
func (m *MockGetUserBalanceUseCase) Execute(ctx context.Context, userID int64) (dto.LoyaltyBalance, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, userID)
	ret0, _ := ret[0].(dto.LoyaltyBalance)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Execute indicates an expected call of Execute.
func (mr *MockGetUserBalanceUseCaseMockRecorder) Execute(ctx, userID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockGetUserBalanceUseCase)(nil).Execute), ctx, userID)
}

// MockConclusionUserBalanceUseCase is a mock of ConclusionUserBalanceUseCase interface.
type MockConclusionUserBalanceUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockConclusionUserBalanceUseCaseMockRecorder
}

// MockConclusionUserBalanceUseCaseMockRecorder is the mock recorder for MockConclusionUserBalanceUseCase.
type MockConclusionUserBalanceUseCaseMockRecorder struct {
	mock *MockConclusionUserBalanceUseCase
}

// NewMockConclusionUserBalanceUseCase creates a new mock instance.
func NewMockConclusionUserBalanceUseCase(ctrl *gomock.Controller) *MockConclusionUserBalanceUseCase {
	mock := &MockConclusionUserBalanceUseCase{ctrl: ctrl}
	mock.recorder = &MockConclusionUserBalanceUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockConclusionUserBalanceUseCase) EXPECT() *MockConclusionUserBalanceUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method.
func (m *MockConclusionUserBalanceUseCase) Execute(ctx context.Context, balance dto.LoyaltyBalance) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, balance)
	ret0, _ := ret[0].(error)
	return ret0
}

// Execute indicates an expected call of Execute.
func (mr *MockConclusionUserBalanceUseCaseMockRecorder) Execute(ctx, balance interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockConclusionUserBalanceUseCase)(nil).Execute), ctx, balance)
}

// MockCreateUserBalanceUseCase is a mock of CreateUserBalanceUseCase interface.
type MockCreateUserBalanceUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockCreateUserBalanceUseCaseMockRecorder
}

// MockCreateUserBalanceUseCaseMockRecorder is the mock recorder for MockCreateUserBalanceUseCase.
type MockCreateUserBalanceUseCaseMockRecorder struct {
	mock *MockCreateUserBalanceUseCase
}

// NewMockCreateUserBalanceUseCase creates a new mock instance.
func NewMockCreateUserBalanceUseCase(ctrl *gomock.Controller) *MockCreateUserBalanceUseCase {
	mock := &MockCreateUserBalanceUseCase{ctrl: ctrl}
	mock.recorder = &MockCreateUserBalanceUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCreateUserBalanceUseCase) EXPECT() *MockCreateUserBalanceUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method.
func (m *MockCreateUserBalanceUseCase) Execute(ctx context.Context, userID int64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, userID)
	ret0, _ := ret[0].(error)
	return ret0
}

// Execute indicates an expected call of Execute.
func (mr *MockCreateUserBalanceUseCaseMockRecorder) Execute(ctx, userID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockCreateUserBalanceUseCase)(nil).Execute), ctx, userID)
}
